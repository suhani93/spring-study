# Constant 대신 Enum 을 사용하면 좋은 이유

> 1. Type Safety 하다.
> 2. 싱글톤을 보장해준다.
> 3. 매서드를 정의 및 재정의가 가능하다.



# 서비스 추상화

> 하위 시스템의 공통점을 뽑아내서 분리시키는 것을 말한다.
>
> 추상화를 하게 되면 비슷한 부분끼리 모여고(강한 응집력) 서로 다른 코드들이 서로를 구속하지 않는(낮은 결합도) 프로그램을 개발 할 수 있다.



# 트랜잭션

> 쪼개질 수 없는 업무처리의 단위
>
> 트랜잭션(Transaction)은 데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 모두 수행되어야 할 일련의 연산들을 의미



# 트랜잭션의 성질

1. **Atomicity(원자성)**

   > 트랜잭션 내의 연산은 데이터베이스에 모두 반영되든지 아니면 전혀 반영되지 않아야 한다.

   

2. **Consistency(일관성)**

   > 트랜잭션이 그 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 변환한다.

   

3. **Isolation(독립성,격리성)**

   > 수행중인 트랜잭션은 완전히 완료될 때까지 다른 트랜잭션에서 수행 결과를 참조할 수 없다.

   

4. **Durablility(영속성,지속성)**

   > 성공적으로 완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 한다.





# 트랜잭션 연상 및 상태

- Commit 연산

  >Commit 연산은 한개의 논리적 단위(트랜잭션)에 대한 작업이 성공적으로 끝났고 데이터베이스가 다시 일관된 상태에 있을 때, 이 트랜잭션이 행한 갱신 연산이 완료된 것을 트랜잭션 관리자에게 알려주는 연산이다.

- Rollback 연산

  > Rollback 연산은 하나의 트랜잭션 처리가 비정상적으로 종료되어 데이터베이스의 일관성을 깨뜨렸을 때, 이 트랜잭션의 일부가 정상적으로 처리되었더라도 트랜잭션의 원자성을 구현하기 위해 이 트랜잭션이 행한 모든 연산을 취소(Undo)하는 연산이다.

  > Rollback시에는 해당 트랜잭션을 재시작하거나 폐기한다.





# 트랜잭션 경계 설정

> 트랜잭션이 존재하는 범위, 즉 트랜잭션이 시작하는 곳과 끝나는 곳을 지정하는 것이다.



# 트랜잭션 경계 설정 구조

보통의 트랜잭션이 설정되어 있는 로직의 코드는 아래와 같이 만들어야 한다.

```
public void doSomething() {
		(1) DB connection 생성
    	(2) 트랜잭션 시작
    try {
    	(3) DB 관련 작업
        (4) 트랜잭션 커밋
    } catch(Exception e) {
    	(5) 트랜잭션 롤백
    } finally {
    	(6) DB connection 종료
    }
}
```



만약 같은 트랜잭션에서 작업을 하기 위해서는 트랜잭션이 필요한 모든 메소드에 Parameter로 Connection 객체를 넘겨줘야 하는 문제가 발생한다. 이러한 점을 해결하기 위하여 스프링에서는 트랜잭션 동기화 라는 기법을 사용하고 있다,



# 트랜잭션 동기화

> 스프링에서는  제공하는 트랜잭션 관리 방법으로 어떤 서비스 로직에서 트랜잭션을 시작하기 위해 만든 Connection 오브젝트를 **특별한 저장소**에 보관해두고, 이후에 호출되는 로직에서 저장된 Connection을 가져다가 사용하게 하는 것이다.



# 트랜잭션 동기화 저장소

> org.springframework.transaction.support 패키지 안에 있는 TransactionSynchronizationManager.java를 까보면 ThreadLocal을 사용하여 구현되어 있다. 즉, 멀티 쓰레드 환경에서 작업해도 안전하다.





# 트랜잭션 동기화 저장소 사용 로직


<img width="922" alt="트랜잭션 동기화 저장소" src="https://user-images.githubusercontent.com/73545607/124289403-3de19e00-db8d-11eb-9c09-4ba2bdf355ec.png">


1. Connection 생성 (1)

2. 트랜잭션 동기화 저장소에 저장 후 트랜잭션 시작 (2)

3. update 시작 (3)

4. 트랜잭션 동기화 저장소에 현재 트랜잭션을 가진 Connection 오브잭트가 있는지 확인 후 있으면 가져온다.  (4)
5. Connection을 이용해 SQL을 실행한다 (5)
6. 반복 (6 ~ 11)
7. 모든 작업이 끝나면 트랜잭션을 Commit으로 완료시킨다. (12)
8. 트랜잭션 동기화 저장소에 있는 Connection을 제거한다. (13)





# 트랜잭션 종류

- Local Transaction 

  > 하나의 Datasource에서 발생하는 자체적인 트랜잭션만 관리하는 것을 말한다.
  >
  > 자바는 JDBC 에서 지원한다.

- Global Transaction

  > 여러개의 Datasource에서 발생하는 트랜잭션을 관리하는 것을 말한다.
  >
  > 자바는 JDBC 외에 이런 글로벌 트랜잭션을 지원하는 트랜잭션 매니저를 지원하기 위한 JTA를 제공한다.





# 스프링의 트랜잭션 서비스 추상화

>스프링에서는 데이터 액세스 기술 API에 의존하지 않고 일관된 방식으로 트랜잭션을 제어할 수 있도록 추상화 했다.

![스프링 트랜잭션 서비스 추상화](https://user-images.githubusercontent.com/73545607/124289438-4b972380-db8d-11eb-9263-1b39a3185a47.png)





# 테스트 대역

> 테스트 환경을 만들어주기 위해, 테스트 대상이 되는 오브젝트의 기능에만 충실하게 수행하면서 빠르게, 자주 테스트를 실행할 수 있도록 사용하는 오브젝트를 말한다.
>
> 대표적인 테스트 대역은 테스트 스텁(test stub)이다.



# 테스트 스텁

> Dummy 객체가 실제로 동작하는 것 처럼 보이게 만들어 놓은 객체이며 테스트 중에 호출되면 미리 의도한 결과를 반환하는 것이다.



# Mock

> 호출했을 때 사전에 정의된 명세대로의 결과를 돌려주도록 미리 프로그램 돼있는 것이다



# 테스트 대역의 장점

1. 실제로 테스트 불가능한 외부 API에 대하여 테스트가 가능하다.
2. 실제로 API를 호출 후 대기하는 것이 아니라 빠른 테스트가 가능하다.



